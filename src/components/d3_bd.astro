<!-- Create a div where the graph will take place -->
<div id="my_dataviz_container">
<div id="my_dataviz"></div>
<div id="slider-range"></div>
</div>

<!-- Load d3.js -->
<script is:inline src="https://d3js.org/d3.v7.min.js"></script>
<script is:inline src="https://unpkg.com/d3-simple-slider"></script>

<script >
function convertRow(d) {
  return {
    year: parseInt(d.year),
    month: parseInt(d.month),
    day: parseInt(d.day),
    births: parseInt(d.births),
    //weekday: parseInt(d.weekday),
  }
};

function groupBirths(data, startYear = 1907, endYear = 2003) {
  // 1. First, filter the data by the specified year range
  const filteredData = data.filter(record => {
    return record.year >= startYear && record.year <= endYear;
  });

  // 2. Now, apply the grouping logic to the filtered data
  const groupedData = {};
  filteredData.forEach(record => {
    const key = `${record.month}-${record.day}`;
    if (!groupedData[key]) {
      groupedData[key] = {
        month: record.month,
        day: record.day,
        births: 0
      };
    }
    groupedData[key].births += record.births;
  });
  // 3. Convert the groupedData object back into a sorted array of objects
  const result = Object.values(groupedData);
  result.sort((a, b) => {
    if (a.month !== b.month) {
      return a.month - b.month;
    }
    return a.day - b.day;
  });
  return result;
};

// set the dimensions and margins of the graph
const margin = {top: 80, right: 25, bottom: 30, left: 40},
  width = 500 - margin.left - margin.right,
  height = 800 - margin.top - margin.bottom;

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
.append("svg")
  .attr("width", width + margin.left + margin.right)
  .attr("height", height + margin.top + margin.bottom)
.append("g")
  .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");

//Read the data
d3.csv("https://raw.githubusercontent.com/khchtr/OpenData/refs/heads/main/Demographics/birthdays.csv", convertRow).then(function(source_data) {
  let data= groupBirths(source_data)

  // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
  //const months = Array.from(new Set(data.map(d => d.month)))
  //const days = Array.from(new Set(data.map(d => d.day)))

  // Build X scales and axis:
  const x = d3.scaleBand()
    .range([ 0, width ])
    .domain(Array.from({ length: 12 }, (_, i) => i + 1))
    .padding(0.05);

 const xAxis = svg.append("g")
    .style("font-size", 15)
    .attr("transform", "translate(0,-5)")
    .call(d3.axisTop(x).tickSize(0).tickFormat(d => { // Changed to axisTop
            const date = new Date(2000, d - 1, 1); // Use a dummy date to get month name
            return d3.timeFormat("%b")(date); // Format to abbreviated month name (e.g., "Jan")
        }))
    .select(".domain").remove();

  // Build Y scales and axis:
  const y = d3.scaleBand()
    .range([ height, 0 ])
    .domain(Array.from({ length: 31 }, (_, i) => 31 - i))
    .padding(0.05);

 const yAxis = svg.append("g")
    .style("font-size", 15)
    .call(d3.axisLeft(y).tickSize(0))
    .select(".domain").remove();

  // Build color scale
  //var myColor = d3.scaleSequential()
  //  .interpolator(d3.interpolateRdBu)
  //  .domain([1,30000])
let color = d3.scaleDiverging([d3.min(data, d => d.births), 0, d3.max(data, d => d.births)], d3.interpolateSpectral)
let myColor = d3.scaleLinear()
  .domain([28000, 6900, 1500])
  .range(['red', '#fff', 'blue']);

  // add the squares
  svg.selectAll()
    .data(data, function(d) {return d.month+':'+d.day;})
    .join("rect")
      .attr("x", function(d) { return x(d.month) })
      .attr("y", function(d) { return y(d.day) })
      .attr("rx", 0)
      .attr("ry", 0)
      .attr("width", x.bandwidth() )
      .attr("height", y.bandwidth() )
      .style("fill", d => myColor(d.births))
      .style("stroke-width", 4)
      .style("stroke", "none")
      .style("opacity", 0.8)

    
  var cell = svg.selectAll(".label")
    .data(data)
    .enter()
    .append("g")
    .attr("class", "label")

  cell
    .append("text")
    .attr("x", (d) => x(d.month))
    .attr("y", (d) => y(d.day))
    .attr("dx", x.bandwidth()/2)
    .attr("dy", y.bandwidth()/2)
    .attr("text-anchor", "middle")
    .style("font-size", "16px")
    .style("fill", "black")
    .style('dominant-baseline', 'middle')
    .text((d) => Math.round(d.births/1000 * 10) / 10);

  cell
    .append("title")
      .text(d => `${d.births.toLocaleString("en")} births`)


  // Define the slider

  let min = 1907;
  let max = 2003;
  var sliderRange = d3
    .sliderBottom()
    .min(min)
    .max(max)
    .width(300)
    .step(1)
    .ticks(0)
    .default([min, max])
    .fill('#212529')
    .displayFormat(d3.format('.0f'))
    .tickFormat(d3.format('.0f'))
    //d3.select('p#value-range').text(val.map(d3.format('.2%')).join('-'))
    //To be changed Filter data based on slider values
    // const filteredData = data.filter(d => d.Date >= val[0] && d.Date <= val[1]);


  sliderRange.on('onchange', val=> {
    let data_new = groupBirths(source_data,val[0], val[1])
    let min = d3.min(data_new, d => d.births)
    let max = d3.max(data_new, d => d.births)

    myColor
    .domain([max,(min+max)/2, min])
    
    svg.selectAll("rect")
    .data(data_new, function(d) {return d.month+':'+d.day;})
    .style("fill", function(d) { return myColor(d.births)}
  )

    var cell = svg.selectAll(".label")
    .data(data_new)

    cell.select("text")
    .text((d) => Math.round(d.births/1000 * 10) / 10)

    cell.select("title")
    .text((d) => `${d.births.toLocaleString("en")} births`)
    
  });


  // Add the slider to the DOM
  var gRange = d3
    .select('div#slider-range')
    .append('svg')
    .attr('width', 500)
    .attr('height', 100)
    .append('g')
    .attr('transform', 'translate(90,10)');

  gRange.call(sliderRange);


// Add title to graph
svg.append("text")
        .attr("x", 0)
        .attr("y", -30)
        .attr("text-anchor", "left")
        .style("font-size", "18px")
        .text("Number of births in Armenia (in thousands)");

});
</script>